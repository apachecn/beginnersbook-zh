# DBMS 冲突可序列化

> 原文： [https://beginnersbook.com/2018/12/dbms-conflict-serializability/](https://beginnersbook.com/2018/12/dbms-conflict-serializability/)

在 [DBMS 计划](https://beginnersbook.com/2018/12/dbms-schedules/)指南中，我们了解到有两种类型的计划 - 串行和计划。非串联。串行调度不支持并发执行事务，而非串行调度支持并发。我们还在 [Serializability](https://beginnersbook.com/2018/12/dbms-serializability/) 教程中了解到，非串行调度可能会使数据库处于不一致状态，因此我们需要检查这些非串行调度以获得可串行化。

**冲突可串行化**是可串行化类型之一，可用于检查非串行调度是否可冲突序列化。

## 什么是冲突可串行化？

如果我们可以在交换其非冲突操作后将其转换为串行调度，则调度称为冲突可序列化。

### 冲突的行动

如果它们满足以下三个条件，则说两个操作存在冲突：

这两项业务都属于不同的交易。
2.两个操作都在同一个数据项上运行。
3.至少有一个操作是写操作。

让我们看一些例子来理解这一点：
**例 1：**事务 T1 的操作 W（X）和事务 T2 的操作 R（X）是冲突操作，因为它们满足上述所有三个条件。它们属于不同的事务，它们正在处理相同的数据项 X，这是写操作中的一个操作。

**示例 2：**类似地，T1 的操作 W（X）和 T2 的 W（X）是冲突操作。

**例 3：** T1 的操作 W（X）和 T2 的 W（Y）是非冲突操作，因为两个写操作都不在同一数据项上工作，因此这些操作不满足第二个条件。

**例 4：**类似地，T1 的 R（X）和 T2 的 R（X）是非冲突操作，因为它们都不是写操作。

**示例 5：**类似地，T1 的 T1 和 R（X）的 W（X）是非冲突操作，因为两个操作属于同一事务 T1。

## 冲突等价时间表

如果在交换非冲突操作之后可以将一个计划转换为其他计划，则称两个计划是冲突等效。

## 冲突可序列化检查

让我们检查一个计划是否可以冲突序列化。如果计划冲突等同于其序列计划，则称为冲突可序列化计划。让我们举几个时间表的例子。

### 冲突可序列化的示例

让我们考虑这个时间表：

```
T1         T2
-----     ------
R(A)
R(B)
          R(A)
          R(B)
          W(B)
W(A)

```

要将此计划转换为连续计划，我们必须将事务 T2 的 R（A）操作与事务 T1 的 W（A）操作交换。但是我们不能交换这两个操作，因为它们是冲突操作，因此我们可以说这个给定的时间表是**而不是冲突可序列化**。

让我们再看一个例子：

```
T1         T2
-----     ------
R(A)
          R(A)
          R(B)
          W(B)
R(B)
W(A)

```

让**交换非冲突操作**：

在交换 T1 的 R（A）和 T2 的 R（A）后，我们得到：

```
T1         T2
-----     ------
          R(A)
R(A)
          R(B)
          W(B)
R(B)
W(A)

```

在交换 T1 的 R（A）和 T2 的 R（B）后，我们得到：

```
T1         T2
-----     ------
          R(A)
          R(B)
R(A) 
          W(B)
R(B)
W(A)

```

在交换 T1 的 R（A）和 T2 的 W（B）后，我们得到：

```
T1         T2
-----     ------
          R(A)
          R(B)
          W(B)
R(A)         
R(B)
W(A)

```

在交换所有非冲突操作后，我们终于得到了一个连续的时间表，因此我们可以说给定的时间表是**冲突可序列化**。